"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chartjs-plugin-zoom";
exports.ids = ["vendor-chunks/chartjs-plugin-zoom"];
exports.modules = {

/***/ "(ssr)/./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plugin),\n/* harmony export */   pan: () => (/* binding */ pan),\n/* harmony export */   resetZoom: () => (/* binding */ resetZoom),\n/* harmony export */   zoom: () => (/* binding */ zoom),\n/* harmony export */   zoomRect: () => (/* binding */ zoomRect),\n/* harmony export */   zoomScale: () => (/* binding */ zoomScale)\n/* harmony export */ });\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hammerjs */ \"(ssr)/./node_modules/hammerjs/hammer.js\");\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js/helpers */ \"(ssr)/./node_modules/chart.js/helpers/helpers.js\");\n/*!\n* chartjs-plugin-zoom v2.2.0\n* https://www.chartjs.org/chartjs-plugin-zoom/2.2.0/\n * (c) 2016-2024 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\n\n\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({chart});\n  }\n  if (typeof mode === 'string') {\n    return {x: mode.indexOf('x') !== -1, y: mode.indexOf('y') !== -1};\n  }\n  return {x: false, y: false};\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {mode = 'xy', scaleMode, overScaleMode} = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  const enabledScales = [];\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(chart.scales, function(scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {},\n      dragging: false,\n      panning: false\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(val, min, range, newRange) {\n  const minPercent = Math.max(0, Math.min(1, (val - min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getValueAtPoint(scale, point) {\n  const pixel = scale.isHorizontal() ? point.x : point.y;\n  return scale.getValueForPixel(pixel);\n}\nfunction linearZoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerValue = getValueAtPoint(scale, center);\n  return zoomDelta(centerValue, scale.min, range, newRange);\n}\nfunction logarithmicZoomRange(scale, zoom, center) {\n  const centerValue = getValueAtPoint(scale, center);\n  if (centerValue === undefined) {\n    return {min: scale.min, max: scale.max};\n  }\n  const logMin = Math.log10(scale.min);\n  const logMax = Math.log10(scale.max);\n  const logCenter = Math.log10(centerValue);\n  const logRange = logMax - logMin;\n  const newLogRange = logRange * (zoom - 1);\n  const delta = zoomDelta(logCenter, logMin, logRange, newLogRange);\n  return {\n    min: Math.pow(10, logMin + delta.min),\n    max: Math.pow(10, logMax - delta.max),\n  };\n}\nfunction getScaleLimits(scale, limits) {\n  return limits && (limits[scale.id] || limits[scale.axis]) || {};\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.valueOrDefault)(original.options, original.scale);\n  }\n  return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.valueOrDefault)(limit, fallback);\n}\nfunction linearRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction fixRange(range, {min, max, minLimit, maxLimit}, originalLimits) {\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  const origMin = originalLimits.min.options ?? originalLimits.min.scale;\n  const origMax = originalLimits.max.options ?? originalLimits.max.scale;\n  const epsilon = range / 1e6;\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.almostEquals)(min, origMin, epsilon)) {\n    min = origMin;\n  }\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.almostEquals)(max, origMax, epsilon)) {\n    max = origMax;\n  }\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  return {min, max};\n}\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {options: scaleOpts} = scale;\n  const scaleLimits = getScaleLimits(scale, limits);\n  const {minRange = 0} = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  if (zoom === 'pan' && (min < minLimit || max > maxLimit)) {\n    return true;\n  }\n  const scaleRange = scale.max - scale.min;\n  const range = zoom ? Math.max(max - min, minRange) : scaleRange;\n  if (zoom && range === minRange && scaleRange <= minRange) {\n    return true;\n  }\n  const newRange = fixRange(range, {min, max, minLimit, maxLimit}, state.originalScaleLimits[scale.id]);\n  scaleOpts.min = newRange.min;\n  scaleOpts.max = newRange.max;\n  state.updatedScaleLimits[scale.id] = newRange;\n  return scale.parse(newRange.min) !== scale.min || scale.parse(newRange.max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomLogarithmicScale(scale, zoom, center, limits) {\n  const newRange = logarithmicZoomRange(scale, zoom, center);\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, linearRange(scale, from, to), limits, true);\n}\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  const range = Math.max(max - min, 1);\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {min, max}, limits) || applied;\n}\nconst OFFSETS = {\n  second: 500,\n  minute: 30 * 1000,\n  hour: 30 * 60 * 1000,\n  day: 12 * 60 * 60 * 1000,\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  month: 15 * 24 * 60 * 60 * 1000,\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  year: 182 * 24 * 60 * 60 * 1000\n};\nfunction panNumericalScale(scale, delta, limits, pan = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  if (isNaN(newMin) || isNaN(newMax)) {\n    return true;\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, pan ? 'pan' : false);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n  logarithmic: zoomLogarithmicScale,\n};\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale,\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {id, options: {min, max}} = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  const {scales} = chart;\n  const {originalScaleLimits, updatedScaleLimits} = state;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(scales, function(scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {scale: scale.min, options: scale.options.min},\n        max: {scale: scale.max, options: scale.options.max},\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(fn, [scale, from, to, limits]);\n}\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\nfunction zoom(chart, amount, transition = 'none', trigger = 'api') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(zoomOptions.onZoom, [{chart, trigger}]);\n}\nfunction zoomRect(chart, p0, p1, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy'} = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(zoomOptions.onZoom, [{chart, trigger}]);\n}\nfunction zoomScale(chart, scaleId, range, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.zoom?.onZoom, [{chart, trigger}]);\n}\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n    delete state.updatedScaleLimits[scale.id];\n  });\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.zoom.onZoomComplete, [{chart}]);\n}\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {min, max} = original;\n  return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.valueOrDefault)(max.options, max.scale) - (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.valueOrDefault)(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(chart.scales, function(scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  const {panDelta} = state;\n  const storedDelta = panDelta[scale.id] || 0;\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.sign)(storedDelta) === (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.sign)(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(fn, [scale, delta, limits])) {\n    panDelta[scale.id] = 0;\n  } else {\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const state = getState(chart);\n  const {options: {pan: panOptions, limits}} = state;\n  const {onPan} = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onPan, [{chart}]);\n}\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\n  }\n  return scaleBounds;\n}\nfunction getZoomedScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    scaleBounds[scaleId] = state.updatedScaleLimits[scaleId];\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isZoomingOrPanning(chart) {\n  const state = getState(chart);\n  return state.panning || state.dragging;\n}\n\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\nfunction removeHandler(chart, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  handlers[type].target = target;\n  const passive = type === 'wheel' ? false : undefined;\n  target.addEventListener(type, handlers[type], {passive});\n}\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction getPointPosition(event, chart) {\n  if (event.target !== chart.canvas) {\n    const canvasArea = chart.canvas.getBoundingClientRect();\n    return {\n      x: event.clientX - canvasArea.left,\n      y: event.clientY - canvasArea.top,\n    };\n  }\n  return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.getRelativePosition)(event, chart);\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const point = getPointPosition(event, chart);\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onZoomStart, [{chart, event, point}]) === false) {\n      (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  if (chart.legend) {\n    const point = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.getRelativePosition)(event, chart);\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__._isPointInArea)(point, chart.legend)) {\n      return;\n    }\n  }\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n  if (\n    event.button !== 0 ||\n    keyPressed(getModifierKey(panOptions), event) ||\n    keyNotPressed(getModifierKey(zoomOptions.drag), event)\n  ) {\n    return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas.ownerDocument, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction applyAspectRatio({begin, end}, aspectRatio) {\n  let width = end.x - begin.x;\n  let height = end.y - begin.y;\n  const ratio = Math.abs(width / height);\n  if (ratio > aspectRatio) {\n    width = Math.sign(width) * Math.abs(height * aspectRatio);\n  } else if (ratio < aspectRatio) {\n    height = Math.sign(height) * Math.abs(width / aspectRatio);\n  }\n  end.x = begin.x + width;\n  end.y = begin.y + height;\n}\nfunction applyMinMaxProps(rect, chartArea, points, {min, max, prop}) {\n  rect[min] = clamp(Math.min(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n  rect[max] = clamp(Math.max(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n}\nfunction getRelativePoints(chart, pointEvents, maintainAspectRatio) {\n  const points = {\n    begin: getPointPosition(pointEvents.dragStart, chart),\n    end: getPointPosition(pointEvents.dragEnd, chart),\n  };\n  if (maintainAspectRatio) {\n    const aspectRatio = chart.chartArea.width / chart.chartArea.height;\n    applyAspectRatio(points, aspectRatio);\n  }\n  return points;\n}\nfunction computeDragRect(chart, mode, pointEvents, maintainAspectRatio) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  const {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n  const rect = {top, left, right, bottom};\n  const points = getRelativePoints(chart, pointEvents, maintainAspectRatio && xEnabled && yEnabled);\n  if (xEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {min: 'left', max: 'right', prop: 'x'});\n  }\n  if (yEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {min: 'top', max: 'bottom', prop: 'y'});\n  }\n  const width = rect.right - rect.left;\n  const height = rect.bottom - rect.top;\n  return {\n    ...rect,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  const {mode, onZoomComplete, drag: {threshold = 0, maintainAspectRatio}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, {dragStart: state.dragStart, dragEnd: event}, maintainAspectRatio);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom', 'drag');\n  state.dragging = false;\n  state.filterNextClick = true;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onZoomComplete, [{chart}]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(zoomOptions.onZoomRejected, [{chart, event}]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const speed = zoomOptions.wheel.speed;\n  const percentage = event.deltaY >= 0 ? 2 - 1 / (1 - speed) : 1 + speed;\n  const amount = {\n    x: percentage,\n    y: percentage,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount, 'zoom', 'wheel');\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onZoomComplete, [{chart}]);\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(handler, [{chart}]), delay);\n  }\n}\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\n\nfunction createEnabler(chart, state) {\n  return function(recognizer, event) {\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount, 'zoom', 'pinch');\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state, event) {\n  if (state.options.zoom.pinch.enabled) {\n    const point = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.getRelativePosition)(event, chart);\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.zoom.onZoomStart, [{chart, event, point}]) === false) {\n      state.scale = null;\n      (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.zoom.onZoomRejected, [{chart, event}]);\n    } else {\n      state.scale = 1;\n    }\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null;\n    (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\nfunction startPan(chart, state, event) {\n  const {enabled, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onPanStart, [{chart, event, point}]) === false) {\n    return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onPanRejected, [{chart, event}]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {x: 0, y: 0};\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panning = false;\n    state.filterNextClick = true;\n    (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n  const mc = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Manager)(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Pinch)());\n    mc.on('pinchstart', (e) => startPinch(chart, state, e));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Pan)({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nfunction hammerOptionsChanged(oldOptions, newOptions) {\n  const {pan: oldPan, zoom: oldZoom} = oldOptions;\n  const {pan: newPan, zoom: newZoom} = newOptions;\n  if (oldZoom?.zoom?.pinch?.enabled !== newZoom?.zoom?.pinch?.enabled) {\n    return true;\n  }\n  if (oldPan?.enabled !== newPan?.enabled) {\n    return true;\n  }\n  if (oldPan?.threshold !== newPan?.threshold) {\n    return true;\n  }\n  return false;\n}\n\nvar version = \"2.2.0\";\n\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {dragStart, dragEnd} = getState(chart);\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, {dragStart, dragEnd}, dragOptions.maintainAspectRatio);\n  const ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode')\n      || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if ((hammerjs__WEBPACK_IMPORTED_MODULE_0___default())) {\n      startHammer(chart, options);\n    }\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.getZoomedScaleBounds = () => getZoomedScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n    chart.isZoomingOrPanning = () => isZoomingOrPanning(chart);\n  },\n  beforeEvent(chart, {event}) {\n    if (isZoomingOrPanning(chart)) {\n      return false;\n    }\n    if (event.type === 'click' || event.type === 'mouseup') {\n      const state = getState(chart);\n      if (state.filterNextClick) {\n        state.filterNextClick = false;\n        return false;\n      }\n    }\n  },\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    const previousOptions = state.options;\n    state.options = options;\n    if (hammerOptionsChanged(previousOptions, options)) {\n      stopHammer(chart);\n      startHammer(chart, options);\n    }\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function(chart) {\n    removeListeners(chart);\n    if ((hammerjs__WEBPACK_IMPORTED_MODULE_0___default())) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tem9vbS9kaXN0L2NoYXJ0anMtcGx1Z2luLXpvb20uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QjtBQUM2Rjs7QUFFM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVDQUF1QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0RBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUV3RSIsInNvdXJjZXMiOlsid2VicGFjazovL2dvb2R3ZS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tem9vbS9kaXN0L2NoYXJ0anMtcGx1Z2luLXpvb20uZXNtLmpzPzAyMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIGNoYXJ0anMtcGx1Z2luLXpvb20gdjIuMi4wXG4qIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnL2NoYXJ0anMtcGx1Z2luLXpvb20vMi4yLjAvXG4gKiAoYykgMjAxNi0yMDI0IGNoYXJ0anMtcGx1Z2luLXpvb20gQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IEhhbW1lciBmcm9tICdoYW1tZXJqcyc7XG5pbXBvcnQgeyBlYWNoLCB2YWx1ZU9yRGVmYXVsdCwgYWxtb3N0RXF1YWxzLCBjYWxsYmFjaywgc2lnbiwgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgX2lzUG9pbnRJbkFyZWEgfSBmcm9tICdjaGFydC5qcy9oZWxwZXJzJztcblxuY29uc3QgZ2V0TW9kaWZpZXJLZXkgPSBvcHRzID0+IG9wdHMgJiYgb3B0cy5lbmFibGVkICYmIG9wdHMubW9kaWZpZXJLZXk7XG5jb25zdCBrZXlQcmVzc2VkID0gKGtleSwgZXZlbnQpID0+IGtleSAmJiBldmVudFtrZXkgKyAnS2V5J107XG5jb25zdCBrZXlOb3RQcmVzc2VkID0gKGtleSwgZXZlbnQpID0+IGtleSAmJiAhZXZlbnRba2V5ICsgJ0tleSddO1xuZnVuY3Rpb24gZGlyZWN0aW9uRW5hYmxlZChtb2RlLCBkaXIsIGNoYXJ0KSB7XG4gIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbW9kZS5pbmRleE9mKGRpcikgIT09IC0xO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1vZGUoe2NoYXJ0fSkuaW5kZXhPZihkaXIpICE9PSAtMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkaXJlY3Rpb25zRW5hYmxlZChtb2RlLCBjaGFydCkge1xuICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtb2RlID0gbW9kZSh7Y2hhcnR9KTtcbiAgfVxuICBpZiAodHlwZW9mIG1vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHt4OiBtb2RlLmluZGV4T2YoJ3gnKSAhPT0gLTEsIHk6IG1vZGUuaW5kZXhPZigneScpICE9PSAtMX07XG4gIH1cbiAgcmV0dXJuIHt4OiBmYWxzZSwgeTogZmFsc2V9O1xufVxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSk7XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2NhbGVVbmRlclBvaW50KHt4LCB5fSwgY2hhcnQpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICBjb25zdCBzY2FsZUlkcyA9IE9iamVjdC5rZXlzKHNjYWxlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NhbGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1tzY2FsZUlkc1tpXV07XG4gICAgaWYgKHkgPj0gc2NhbGUudG9wICYmIHkgPD0gc2NhbGUuYm90dG9tICYmIHggPj0gc2NhbGUubGVmdCAmJiB4IDw9IHNjYWxlLnJpZ2h0KSB7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RW5hYmxlZFNjYWxlc0J5UG9pbnQob3B0aW9ucywgcG9pbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHttb2RlID0gJ3h5Jywgc2NhbGVNb2RlLCBvdmVyU2NhbGVNb2RlfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHNjYWxlID0gZ2V0U2NhbGVVbmRlclBvaW50KHBvaW50LCBjaGFydCk7XG4gIGNvbnN0IGVuYWJsZWQgPSBkaXJlY3Rpb25zRW5hYmxlZChtb2RlLCBjaGFydCk7XG4gIGNvbnN0IHNjYWxlRW5hYmxlZCA9IGRpcmVjdGlvbnNFbmFibGVkKHNjYWxlTW9kZSwgY2hhcnQpO1xuICBpZiAob3ZlclNjYWxlTW9kZSkge1xuICAgIGNvbnN0IG92ZXJTY2FsZUVuYWJsZWQgPSBkaXJlY3Rpb25zRW5hYmxlZChvdmVyU2NhbGVNb2RlLCBjaGFydCk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIFsneCcsICd5J10pIHtcbiAgICAgIGlmIChvdmVyU2NhbGVFbmFibGVkW2F4aXNdKSB7XG4gICAgICAgIHNjYWxlRW5hYmxlZFtheGlzXSA9IGVuYWJsZWRbYXhpc107XG4gICAgICAgIGVuYWJsZWRbYXhpc10gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNjYWxlICYmIHNjYWxlRW5hYmxlZFtzY2FsZS5heGlzXSkge1xuICAgIHJldHVybiBbc2NhbGVdO1xuICB9XG4gIGNvbnN0IGVuYWJsZWRTY2FsZXMgPSBbXTtcbiAgZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlSXRlbSkge1xuICAgIGlmIChlbmFibGVkW3NjYWxlSXRlbS5heGlzXSkge1xuICAgICAgZW5hYmxlZFNjYWxlcy5wdXNoKHNjYWxlSXRlbSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVuYWJsZWRTY2FsZXM7XG59XG5cbmNvbnN0IGNoYXJ0U3RhdGVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldFN0YXRlKGNoYXJ0KSB7XG4gIGxldCBzdGF0ZSA9IGNoYXJ0U3RhdGVzLmdldChjaGFydCk7XG4gIGlmICghc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIG9yaWdpbmFsU2NhbGVMaW1pdHM6IHt9LFxuICAgICAgdXBkYXRlZFNjYWxlTGltaXRzOiB7fSxcbiAgICAgIGhhbmRsZXJzOiB7fSxcbiAgICAgIHBhbkRlbHRhOiB7fSxcbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIHBhbm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgICBjaGFydFN0YXRlcy5zZXQoY2hhcnQsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiByZW1vdmVTdGF0ZShjaGFydCkge1xuICBjaGFydFN0YXRlcy5kZWxldGUoY2hhcnQpO1xufVxuXG5mdW5jdGlvbiB6b29tRGVsdGEodmFsLCBtaW4sIHJhbmdlLCBuZXdSYW5nZSkge1xuICBjb25zdCBtaW5QZXJjZW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHZhbCAtIG1pbikgLyByYW5nZSB8fCAwKSk7XG4gIGNvbnN0IG1heFBlcmNlbnQgPSAxIC0gbWluUGVyY2VudDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG5ld1JhbmdlICogbWluUGVyY2VudCxcbiAgICBtYXg6IG5ld1JhbmdlICogbWF4UGVyY2VudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVBdFBvaW50KHNjYWxlLCBwb2ludCkge1xuICBjb25zdCBwaXhlbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpID8gcG9pbnQueCA6IHBvaW50Lnk7XG4gIHJldHVybiBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKHBpeGVsKTtcbn1cbmZ1bmN0aW9uIGxpbmVhclpvb21EZWx0YShzY2FsZSwgem9vbSwgY2VudGVyKSB7XG4gIGNvbnN0IHJhbmdlID0gc2NhbGUubWF4IC0gc2NhbGUubWluO1xuICBjb25zdCBuZXdSYW5nZSA9IHJhbmdlICogKHpvb20gLSAxKTtcbiAgY29uc3QgY2VudGVyVmFsdWUgPSBnZXRWYWx1ZUF0UG9pbnQoc2NhbGUsIGNlbnRlcik7XG4gIHJldHVybiB6b29tRGVsdGEoY2VudGVyVmFsdWUsIHNjYWxlLm1pbiwgcmFuZ2UsIG5ld1JhbmdlKTtcbn1cbmZ1bmN0aW9uIGxvZ2FyaXRobWljWm9vbVJhbmdlKHNjYWxlLCB6b29tLCBjZW50ZXIpIHtcbiAgY29uc3QgY2VudGVyVmFsdWUgPSBnZXRWYWx1ZUF0UG9pbnQoc2NhbGUsIGNlbnRlcik7XG4gIGlmIChjZW50ZXJWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHttaW46IHNjYWxlLm1pbiwgbWF4OiBzY2FsZS5tYXh9O1xuICB9XG4gIGNvbnN0IGxvZ01pbiA9IE1hdGgubG9nMTAoc2NhbGUubWluKTtcbiAgY29uc3QgbG9nTWF4ID0gTWF0aC5sb2cxMChzY2FsZS5tYXgpO1xuICBjb25zdCBsb2dDZW50ZXIgPSBNYXRoLmxvZzEwKGNlbnRlclZhbHVlKTtcbiAgY29uc3QgbG9nUmFuZ2UgPSBsb2dNYXggLSBsb2dNaW47XG4gIGNvbnN0IG5ld0xvZ1JhbmdlID0gbG9nUmFuZ2UgKiAoem9vbSAtIDEpO1xuICBjb25zdCBkZWx0YSA9IHpvb21EZWx0YShsb2dDZW50ZXIsIGxvZ01pbiwgbG9nUmFuZ2UsIG5ld0xvZ1JhbmdlKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IE1hdGgucG93KDEwLCBsb2dNaW4gKyBkZWx0YS5taW4pLFxuICAgIG1heDogTWF0aC5wb3coMTAsIGxvZ01heCAtIGRlbHRhLm1heCksXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTY2FsZUxpbWl0cyhzY2FsZSwgbGltaXRzKSB7XG4gIHJldHVybiBsaW1pdHMgJiYgKGxpbWl0c1tzY2FsZS5pZF0gfHwgbGltaXRzW3NjYWxlLmF4aXNdKSB8fCB7fTtcbn1cbmZ1bmN0aW9uIGdldExpbWl0KHN0YXRlLCBzY2FsZSwgc2NhbGVMaW1pdHMsIHByb3AsIGZhbGxiYWNrKSB7XG4gIGxldCBsaW1pdCA9IHNjYWxlTGltaXRzW3Byb3BdO1xuICBpZiAobGltaXQgPT09ICdvcmlnaW5hbCcpIHtcbiAgICBjb25zdCBvcmlnaW5hbCA9IHN0YXRlLm9yaWdpbmFsU2NhbGVMaW1pdHNbc2NhbGUuaWRdW3Byb3BdO1xuICAgIGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3JpZ2luYWwub3B0aW9ucywgb3JpZ2luYWwuc2NhbGUpO1xuICB9XG4gIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsaW1pdCwgZmFsbGJhY2spO1xufVxuZnVuY3Rpb24gbGluZWFyUmFuZ2Uoc2NhbGUsIHBpeGVsMCwgcGl4ZWwxKSB7XG4gIGNvbnN0IHYwID0gc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChwaXhlbDApO1xuICBjb25zdCB2MSA9IHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwocGl4ZWwxKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IE1hdGgubWluKHYwLCB2MSksXG4gICAgbWF4OiBNYXRoLm1heCh2MCwgdjEpXG4gIH07XG59XG5mdW5jdGlvbiBmaXhSYW5nZShyYW5nZSwge21pbiwgbWF4LCBtaW5MaW1pdCwgbWF4TGltaXR9LCBvcmlnaW5hbExpbWl0cykge1xuICBjb25zdCBvZmZzZXQgPSAocmFuZ2UgLSBtYXggKyBtaW4pIC8gMjtcbiAgbWluIC09IG9mZnNldDtcbiAgbWF4ICs9IG9mZnNldDtcbiAgY29uc3Qgb3JpZ01pbiA9IG9yaWdpbmFsTGltaXRzLm1pbi5vcHRpb25zID8/IG9yaWdpbmFsTGltaXRzLm1pbi5zY2FsZTtcbiAgY29uc3Qgb3JpZ01heCA9IG9yaWdpbmFsTGltaXRzLm1heC5vcHRpb25zID8/IG9yaWdpbmFsTGltaXRzLm1heC5zY2FsZTtcbiAgY29uc3QgZXBzaWxvbiA9IHJhbmdlIC8gMWU2O1xuICBpZiAoYWxtb3N0RXF1YWxzKG1pbiwgb3JpZ01pbiwgZXBzaWxvbikpIHtcbiAgICBtaW4gPSBvcmlnTWluO1xuICB9XG4gIGlmIChhbG1vc3RFcXVhbHMobWF4LCBvcmlnTWF4LCBlcHNpbG9uKSkge1xuICAgIG1heCA9IG9yaWdNYXg7XG4gIH1cbiAgaWYgKG1pbiA8IG1pbkxpbWl0KSB7XG4gICAgbWluID0gbWluTGltaXQ7XG4gICAgbWF4ID0gTWF0aC5taW4obWluTGltaXQgKyByYW5nZSwgbWF4TGltaXQpO1xuICB9IGVsc2UgaWYgKG1heCA+IG1heExpbWl0KSB7XG4gICAgbWF4ID0gbWF4TGltaXQ7XG4gICAgbWluID0gTWF0aC5tYXgobWF4TGltaXQgLSByYW5nZSwgbWluTGltaXQpO1xuICB9XG4gIHJldHVybiB7bWluLCBtYXh9O1xufVxuZnVuY3Rpb24gdXBkYXRlUmFuZ2Uoc2NhbGUsIHttaW4sIG1heH0sIGxpbWl0cywgem9vbSA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoc2NhbGUuY2hhcnQpO1xuICBjb25zdCB7b3B0aW9uczogc2NhbGVPcHRzfSA9IHNjYWxlO1xuICBjb25zdCBzY2FsZUxpbWl0cyA9IGdldFNjYWxlTGltaXRzKHNjYWxlLCBsaW1pdHMpO1xuICBjb25zdCB7bWluUmFuZ2UgPSAwfSA9IHNjYWxlTGltaXRzO1xuICBjb25zdCBtaW5MaW1pdCA9IGdldExpbWl0KHN0YXRlLCBzY2FsZSwgc2NhbGVMaW1pdHMsICdtaW4nLCAtSW5maW5pdHkpO1xuICBjb25zdCBtYXhMaW1pdCA9IGdldExpbWl0KHN0YXRlLCBzY2FsZSwgc2NhbGVMaW1pdHMsICdtYXgnLCBJbmZpbml0eSk7XG4gIGlmICh6b29tID09PSAncGFuJyAmJiAobWluIDwgbWluTGltaXQgfHwgbWF4ID4gbWF4TGltaXQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgc2NhbGVSYW5nZSA9IHNjYWxlLm1heCAtIHNjYWxlLm1pbjtcbiAgY29uc3QgcmFuZ2UgPSB6b29tID8gTWF0aC5tYXgobWF4IC0gbWluLCBtaW5SYW5nZSkgOiBzY2FsZVJhbmdlO1xuICBpZiAoem9vbSAmJiByYW5nZSA9PT0gbWluUmFuZ2UgJiYgc2NhbGVSYW5nZSA8PSBtaW5SYW5nZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG5ld1JhbmdlID0gZml4UmFuZ2UocmFuZ2UsIHttaW4sIG1heCwgbWluTGltaXQsIG1heExpbWl0fSwgc3RhdGUub3JpZ2luYWxTY2FsZUxpbWl0c1tzY2FsZS5pZF0pO1xuICBzY2FsZU9wdHMubWluID0gbmV3UmFuZ2UubWluO1xuICBzY2FsZU9wdHMubWF4ID0gbmV3UmFuZ2UubWF4O1xuICBzdGF0ZS51cGRhdGVkU2NhbGVMaW1pdHNbc2NhbGUuaWRdID0gbmV3UmFuZ2U7XG4gIHJldHVybiBzY2FsZS5wYXJzZShuZXdSYW5nZS5taW4pICE9PSBzY2FsZS5taW4gfHwgc2NhbGUucGFyc2UobmV3UmFuZ2UubWF4KSAhPT0gc2NhbGUubWF4O1xufVxuZnVuY3Rpb24gem9vbU51bWVyaWNhbFNjYWxlKHNjYWxlLCB6b29tLCBjZW50ZXIsIGxpbWl0cykge1xuICBjb25zdCBkZWx0YSA9IGxpbmVhclpvb21EZWx0YShzY2FsZSwgem9vbSwgY2VudGVyKTtcbiAgY29uc3QgbmV3UmFuZ2UgPSB7bWluOiBzY2FsZS5taW4gKyBkZWx0YS5taW4sIG1heDogc2NhbGUubWF4IC0gZGVsdGEubWF4fTtcbiAgcmV0dXJuIHVwZGF0ZVJhbmdlKHNjYWxlLCBuZXdSYW5nZSwgbGltaXRzLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHpvb21Mb2dhcml0aG1pY1NjYWxlKHNjYWxlLCB6b29tLCBjZW50ZXIsIGxpbWl0cykge1xuICBjb25zdCBuZXdSYW5nZSA9IGxvZ2FyaXRobWljWm9vbVJhbmdlKHNjYWxlLCB6b29tLCBjZW50ZXIpO1xuICByZXR1cm4gdXBkYXRlUmFuZ2Uoc2NhbGUsIG5ld1JhbmdlLCBsaW1pdHMsIHRydWUpO1xufVxuZnVuY3Rpb24gem9vbVJlY3ROdW1lcmljYWxTY2FsZShzY2FsZSwgZnJvbSwgdG8sIGxpbWl0cykge1xuICB1cGRhdGVSYW5nZShzY2FsZSwgbGluZWFyUmFuZ2Uoc2NhbGUsIGZyb20sIHRvKSwgbGltaXRzLCB0cnVlKTtcbn1cbmNvbnN0IGludGVnZXJDaGFuZ2UgPSAodikgPT4gdiA9PT0gMCB8fCBpc05hTih2KSA/IDAgOiB2IDwgMCA/IE1hdGgubWluKE1hdGgucm91bmQodiksIC0xKSA6IE1hdGgubWF4KE1hdGgucm91bmQodiksIDEpO1xuZnVuY3Rpb24gZXhpc3RDYXRlZ29yeUZyb21NYXhab29tKHNjYWxlKSB7XG4gIGNvbnN0IGxhYmVscyA9IHNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBtYXhJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xuICBpZiAoc2NhbGUubWluID4gMCkge1xuICAgIHNjYWxlLm1pbiAtPSAxO1xuICB9XG4gIGlmIChzY2FsZS5tYXggPCBtYXhJbmRleCkge1xuICAgIHNjYWxlLm1heCArPSAxO1xuICB9XG59XG5mdW5jdGlvbiB6b29tQ2F0ZWdvcnlTY2FsZShzY2FsZSwgem9vbSwgY2VudGVyLCBsaW1pdHMpIHtcbiAgY29uc3QgZGVsdGEgPSBsaW5lYXJab29tRGVsdGEoc2NhbGUsIHpvb20sIGNlbnRlcik7XG4gIGlmIChzY2FsZS5taW4gPT09IHNjYWxlLm1heCAmJiB6b29tIDwgMSkge1xuICAgIGV4aXN0Q2F0ZWdvcnlGcm9tTWF4Wm9vbShzY2FsZSk7XG4gIH1cbiAgY29uc3QgbmV3UmFuZ2UgPSB7bWluOiBzY2FsZS5taW4gKyBpbnRlZ2VyQ2hhbmdlKGRlbHRhLm1pbiksIG1heDogc2NhbGUubWF4IC0gaW50ZWdlckNoYW5nZShkZWx0YS5tYXgpfTtcbiAgcmV0dXJuIHVwZGF0ZVJhbmdlKHNjYWxlLCBuZXdSYW5nZSwgbGltaXRzLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHNjYWxlTGVuZ3RoKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5pc0hvcml6b250YWwoKSA/IHNjYWxlLndpZHRoIDogc2NhbGUuaGVpZ2h0O1xufVxuZnVuY3Rpb24gcGFuQ2F0ZWdvcnlTY2FsZShzY2FsZSwgZGVsdGEsIGxpbWl0cykge1xuICBjb25zdCBsYWJlbHMgPSBzY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3QgbGFzdExhYmVsSW5kZXggPSBsYWJlbHMubGVuZ3RoIC0gMTtcbiAgbGV0IHttaW4sIG1heH0gPSBzY2FsZTtcbiAgY29uc3QgcmFuZ2UgPSBNYXRoLm1heChtYXggLSBtaW4sIDEpO1xuICBjb25zdCBzdGVwRGVsdGEgPSBNYXRoLnJvdW5kKHNjYWxlTGVuZ3RoKHNjYWxlKSAvIE1hdGgubWF4KHJhbmdlLCAxMCkpO1xuICBjb25zdCBzdGVwU2l6ZSA9IE1hdGgucm91bmQoTWF0aC5hYnMoZGVsdGEgLyBzdGVwRGVsdGEpKTtcbiAgbGV0IGFwcGxpZWQ7XG4gIGlmIChkZWx0YSA8IC1zdGVwRGVsdGEpIHtcbiAgICBtYXggPSBNYXRoLm1pbihtYXggKyBzdGVwU2l6ZSwgbGFzdExhYmVsSW5kZXgpO1xuICAgIG1pbiA9IHJhbmdlID09PSAxID8gbWF4IDogbWF4IC0gcmFuZ2U7XG4gICAgYXBwbGllZCA9IG1heCA9PT0gbGFzdExhYmVsSW5kZXg7XG4gIH0gZWxzZSBpZiAoZGVsdGEgPiBzdGVwRGVsdGEpIHtcbiAgICBtaW4gPSBNYXRoLm1heCgwLCBtaW4gLSBzdGVwU2l6ZSk7XG4gICAgbWF4ID0gcmFuZ2UgPT09IDEgPyBtaW4gOiBtaW4gKyByYW5nZTtcbiAgICBhcHBsaWVkID0gbWluID09PSAwO1xuICB9XG4gIHJldHVybiB1cGRhdGVSYW5nZShzY2FsZSwge21pbiwgbWF4fSwgbGltaXRzKSB8fCBhcHBsaWVkO1xufVxuY29uc3QgT0ZGU0VUUyA9IHtcbiAgc2Vjb25kOiA1MDAsXG4gIG1pbnV0ZTogMzAgKiAxMDAwLFxuICBob3VyOiAzMCAqIDYwICogMTAwMCxcbiAgZGF5OiAxMiAqIDYwICogNjAgKiAxMDAwLFxuICB3ZWVrOiAzLjUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICBtb250aDogMTUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICBxdWFydGVyOiA2MCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gIHllYXI6IDE4MiAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbn07XG5mdW5jdGlvbiBwYW5OdW1lcmljYWxTY2FsZShzY2FsZSwgZGVsdGEsIGxpbWl0cywgcGFuID0gZmFsc2UpIHtcbiAgY29uc3Qge21pbjogcHJldlN0YXJ0LCBtYXg6IHByZXZFbmQsIG9wdGlvbnN9ID0gc2NhbGU7XG4gIGNvbnN0IHJvdW5kID0gb3B0aW9ucy50aW1lICYmIG9wdGlvbnMudGltZS5yb3VuZDtcbiAgY29uc3Qgb2Zmc2V0ID0gT0ZGU0VUU1tyb3VuZF0gfHwgMDtcbiAgY29uc3QgbmV3TWluID0gc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHByZXZTdGFydCArIG9mZnNldCkgLSBkZWx0YSk7XG4gIGNvbnN0IG5ld01heCA9IHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwcmV2RW5kICsgb2Zmc2V0KSAtIGRlbHRhKTtcbiAgaWYgKGlzTmFOKG5ld01pbikgfHwgaXNOYU4obmV3TWF4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB1cGRhdGVSYW5nZShzY2FsZSwge21pbjogbmV3TWluLCBtYXg6IG5ld01heH0sIGxpbWl0cywgcGFuID8gJ3BhbicgOiBmYWxzZSk7XG59XG5mdW5jdGlvbiBwYW5Ob25MaW5lYXJTY2FsZShzY2FsZSwgZGVsdGEsIGxpbWl0cykge1xuICByZXR1cm4gcGFuTnVtZXJpY2FsU2NhbGUoc2NhbGUsIGRlbHRhLCBsaW1pdHMsIHRydWUpO1xufVxuY29uc3Qgem9vbUZ1bmN0aW9ucyA9IHtcbiAgY2F0ZWdvcnk6IHpvb21DYXRlZ29yeVNjYWxlLFxuICBkZWZhdWx0OiB6b29tTnVtZXJpY2FsU2NhbGUsXG4gIGxvZ2FyaXRobWljOiB6b29tTG9nYXJpdGhtaWNTY2FsZSxcbn07XG5jb25zdCB6b29tUmVjdEZ1bmN0aW9ucyA9IHtcbiAgZGVmYXVsdDogem9vbVJlY3ROdW1lcmljYWxTY2FsZSxcbn07XG5jb25zdCBwYW5GdW5jdGlvbnMgPSB7XG4gIGNhdGVnb3J5OiBwYW5DYXRlZ29yeVNjYWxlLFxuICBkZWZhdWx0OiBwYW5OdW1lcmljYWxTY2FsZSxcbiAgbG9nYXJpdGhtaWM6IHBhbk5vbkxpbmVhclNjYWxlLFxuICB0aW1lc2VyaWVzOiBwYW5Ob25MaW5lYXJTY2FsZSxcbn07XG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVNjYWxlTGltaXRzKHNjYWxlLCBvcmlnaW5hbFNjYWxlTGltaXRzLCB1cGRhdGVkU2NhbGVMaW1pdHMpIHtcbiAgY29uc3Qge2lkLCBvcHRpb25zOiB7bWluLCBtYXh9fSA9IHNjYWxlO1xuICBpZiAoIW9yaWdpbmFsU2NhbGVMaW1pdHNbaWRdIHx8ICF1cGRhdGVkU2NhbGVMaW1pdHNbaWRdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcHJldmlvdXMgPSB1cGRhdGVkU2NhbGVMaW1pdHNbaWRdO1xuICByZXR1cm4gcHJldmlvdXMubWluICE9PSBtaW4gfHwgcHJldmlvdXMubWF4ICE9PSBtYXg7XG59XG5mdW5jdGlvbiByZW1vdmVNaXNzaW5nU2NhbGVzKGxpbWl0cywgc2NhbGVzKSB7XG4gIGVhY2gobGltaXRzLCAob3B0LCBrZXkpID0+IHtcbiAgICBpZiAoIXNjYWxlc1trZXldKSB7XG4gICAgICBkZWxldGUgbGltaXRzW2tleV07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHN0b3JlT3JpZ2luYWxTY2FsZUxpbWl0cyhjaGFydCwgc3RhdGUpIHtcbiAgY29uc3Qge3NjYWxlc30gPSBjaGFydDtcbiAgY29uc3Qge29yaWdpbmFsU2NhbGVMaW1pdHMsIHVwZGF0ZWRTY2FsZUxpbWl0c30gPSBzdGF0ZTtcbiAgZWFjaChzY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVNjYWxlTGltaXRzKHNjYWxlLCBvcmlnaW5hbFNjYWxlTGltaXRzLCB1cGRhdGVkU2NhbGVMaW1pdHMpKSB7XG4gICAgICBvcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlLmlkXSA9IHtcbiAgICAgICAgbWluOiB7c2NhbGU6IHNjYWxlLm1pbiwgb3B0aW9uczogc2NhbGUub3B0aW9ucy5taW59LFxuICAgICAgICBtYXg6IHtzY2FsZTogc2NhbGUubWF4LCBvcHRpb25zOiBzY2FsZS5vcHRpb25zLm1heH0sXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJlbW92ZU1pc3NpbmdTY2FsZXMob3JpZ2luYWxTY2FsZUxpbWl0cywgc2NhbGVzKTtcbiAgcmVtb3ZlTWlzc2luZ1NjYWxlcyh1cGRhdGVkU2NhbGVMaW1pdHMsIHNjYWxlcyk7XG4gIHJldHVybiBvcmlnaW5hbFNjYWxlTGltaXRzO1xufVxuZnVuY3Rpb24gZG9ab29tKHNjYWxlLCBhbW91bnQsIGNlbnRlciwgbGltaXRzKSB7XG4gIGNvbnN0IGZuID0gem9vbUZ1bmN0aW9uc1tzY2FsZS50eXBlXSB8fCB6b29tRnVuY3Rpb25zLmRlZmF1bHQ7XG4gIGNhbGxiYWNrKGZuLCBbc2NhbGUsIGFtb3VudCwgY2VudGVyLCBsaW1pdHNdKTtcbn1cbmZ1bmN0aW9uIGRvWm9vbVJlY3Qoc2NhbGUsIGZyb20sIHRvLCBsaW1pdHMpIHtcbiAgY29uc3QgZm4gPSB6b29tUmVjdEZ1bmN0aW9uc1tzY2FsZS50eXBlXSB8fCB6b29tUmVjdEZ1bmN0aW9ucy5kZWZhdWx0O1xuICBjYWxsYmFjayhmbiwgW3NjYWxlLCBmcm9tLCB0bywgbGltaXRzXSk7XG59XG5mdW5jdGlvbiBnZXRDZW50ZXIoY2hhcnQpIHtcbiAgY29uc3QgY2EgPSBjaGFydC5jaGFydEFyZWE7XG4gIHJldHVybiB7XG4gICAgeDogKGNhLmxlZnQgKyBjYS5yaWdodCkgLyAyLFxuICAgIHk6IChjYS50b3AgKyBjYS5ib3R0b20pIC8gMixcbiAgfTtcbn1cbmZ1bmN0aW9uIHpvb20oY2hhcnQsIGFtb3VudCwgdHJhbnNpdGlvbiA9ICdub25lJywgdHJpZ2dlciA9ICdhcGknKSB7XG4gIGNvbnN0IHt4ID0gMSwgeSA9IDEsIGZvY2FsUG9pbnQgPSBnZXRDZW50ZXIoY2hhcnQpfSA9IHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInID8ge3g6IGFtb3VudCwgeTogYW1vdW50fSA6IGFtb3VudDtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGNvbnN0IHtvcHRpb25zOiB7bGltaXRzLCB6b29tOiB6b29tT3B0aW9uc319ID0gc3RhdGU7XG4gIHN0b3JlT3JpZ2luYWxTY2FsZUxpbWl0cyhjaGFydCwgc3RhdGUpO1xuICBjb25zdCB4RW5hYmxlZCA9IHggIT09IDE7XG4gIGNvbnN0IHlFbmFibGVkID0geSAhPT0gMTtcbiAgY29uc3QgZW5hYmxlZFNjYWxlcyA9IGdldEVuYWJsZWRTY2FsZXNCeVBvaW50KHpvb21PcHRpb25zLCBmb2NhbFBvaW50LCBjaGFydCk7XG4gIGVhY2goZW5hYmxlZFNjYWxlcyB8fCBjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHhFbmFibGVkKSB7XG4gICAgICBkb1pvb20oc2NhbGUsIHgsIGZvY2FsUG9pbnQsIGxpbWl0cyk7XG4gICAgfSBlbHNlIGlmICghc2NhbGUuaXNIb3Jpem9udGFsKCkgJiYgeUVuYWJsZWQpIHtcbiAgICAgIGRvWm9vbShzY2FsZSwgeSwgZm9jYWxQb2ludCwgbGltaXRzKTtcbiAgICB9XG4gIH0pO1xuICBjaGFydC51cGRhdGUodHJhbnNpdGlvbik7XG4gIGNhbGxiYWNrKHpvb21PcHRpb25zLm9uWm9vbSwgW3tjaGFydCwgdHJpZ2dlcn1dKTtcbn1cbmZ1bmN0aW9uIHpvb21SZWN0KGNoYXJ0LCBwMCwgcDEsIHRyYW5zaXRpb24gPSAnbm9uZScsIHRyaWdnZXIgPSAnYXBpJykge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgY29uc3Qge29wdGlvbnM6IHtsaW1pdHMsIHpvb206IHpvb21PcHRpb25zfX0gPSBzdGF0ZTtcbiAgY29uc3Qge21vZGUgPSAneHknfSA9IHpvb21PcHRpb25zO1xuICBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcbiAgY29uc3QgeEVuYWJsZWQgPSBkaXJlY3Rpb25FbmFibGVkKG1vZGUsICd4JywgY2hhcnQpO1xuICBjb25zdCB5RW5hYmxlZCA9IGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3knLCBjaGFydCk7XG4gIGVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuICAgIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSAmJiB4RW5hYmxlZCkge1xuICAgICAgZG9ab29tUmVjdChzY2FsZSwgcDAueCwgcDEueCwgbGltaXRzKTtcbiAgICB9IGVsc2UgaWYgKCFzY2FsZS5pc0hvcml6b250YWwoKSAmJiB5RW5hYmxlZCkge1xuICAgICAgZG9ab29tUmVjdChzY2FsZSwgcDAueSwgcDEueSwgbGltaXRzKTtcbiAgICB9XG4gIH0pO1xuICBjaGFydC51cGRhdGUodHJhbnNpdGlvbik7XG4gIGNhbGxiYWNrKHpvb21PcHRpb25zLm9uWm9vbSwgW3tjaGFydCwgdHJpZ2dlcn1dKTtcbn1cbmZ1bmN0aW9uIHpvb21TY2FsZShjaGFydCwgc2NhbGVJZCwgcmFuZ2UsIHRyYW5zaXRpb24gPSAnbm9uZScsIHRyaWdnZXIgPSAnYXBpJykge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgc3RvcmVPcmlnaW5hbFNjYWxlTGltaXRzKGNoYXJ0LCBzdGF0ZSk7XG4gIGNvbnN0IHNjYWxlID0gY2hhcnQuc2NhbGVzW3NjYWxlSWRdO1xuICB1cGRhdGVSYW5nZShzY2FsZSwgcmFuZ2UsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIGNoYXJ0LnVwZGF0ZSh0cmFuc2l0aW9uKTtcbiAgY2FsbGJhY2soc3RhdGUub3B0aW9ucy56b29tPy5vblpvb20sIFt7Y2hhcnQsIHRyaWdnZXJ9XSk7XG59XG5mdW5jdGlvbiByZXNldFpvb20oY2hhcnQsIHRyYW5zaXRpb24gPSAnZGVmYXVsdCcpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGNvbnN0IG9yaWdpbmFsU2NhbGVMaW1pdHMgPSBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcbiAgZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgICBpZiAob3JpZ2luYWxTY2FsZUxpbWl0c1tzY2FsZS5pZF0pIHtcbiAgICAgIHNjYWxlT3B0aW9ucy5taW4gPSBvcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlLmlkXS5taW4ub3B0aW9ucztcbiAgICAgIHNjYWxlT3B0aW9ucy5tYXggPSBvcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlLmlkXS5tYXgub3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNjYWxlT3B0aW9ucy5taW47XG4gICAgICBkZWxldGUgc2NhbGVPcHRpb25zLm1heDtcbiAgICB9XG4gICAgZGVsZXRlIHN0YXRlLnVwZGF0ZWRTY2FsZUxpbWl0c1tzY2FsZS5pZF07XG4gIH0pO1xuICBjaGFydC51cGRhdGUodHJhbnNpdGlvbik7XG4gIGNhbGxiYWNrKHN0YXRlLm9wdGlvbnMuem9vbS5vblpvb21Db21wbGV0ZSwgW3tjaGFydH1dKTtcbn1cbmZ1bmN0aW9uIGdldE9yaWdpbmFsUmFuZ2Uoc3RhdGUsIHNjYWxlSWQpIHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBzdGF0ZS5vcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlSWRdO1xuICBpZiAoIW9yaWdpbmFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHttaW4sIG1heH0gPSBvcmlnaW5hbDtcbiAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KG1heC5vcHRpb25zLCBtYXguc2NhbGUpIC0gdmFsdWVPckRlZmF1bHQobWluLm9wdGlvbnMsIG1pbi5zY2FsZSk7XG59XG5mdW5jdGlvbiBnZXRab29tTGV2ZWwoY2hhcnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGxldCBtaW4gPSAxO1xuICBsZXQgbWF4ID0gMTtcbiAgZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgY29uc3Qgb3JpZ1JhbmdlID0gZ2V0T3JpZ2luYWxSYW5nZShzdGF0ZSwgc2NhbGUuaWQpO1xuICAgIGlmIChvcmlnUmFuZ2UpIHtcbiAgICAgIGNvbnN0IGxldmVsID0gTWF0aC5yb3VuZChvcmlnUmFuZ2UgLyAoc2NhbGUubWF4IC0gc2NhbGUubWluKSAqIDEwMCkgLyAxMDA7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGxldmVsKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgbGV2ZWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtaW4gPCAxID8gbWluIDogbWF4O1xufVxuZnVuY3Rpb24gcGFuU2NhbGUoc2NhbGUsIGRlbHRhLCBsaW1pdHMsIHN0YXRlKSB7XG4gIGNvbnN0IHtwYW5EZWx0YX0gPSBzdGF0ZTtcbiAgY29uc3Qgc3RvcmVkRGVsdGEgPSBwYW5EZWx0YVtzY2FsZS5pZF0gfHwgMDtcbiAgaWYgKHNpZ24oc3RvcmVkRGVsdGEpID09PSBzaWduKGRlbHRhKSkge1xuICAgIGRlbHRhICs9IHN0b3JlZERlbHRhO1xuICB9XG4gIGNvbnN0IGZuID0gcGFuRnVuY3Rpb25zW3NjYWxlLnR5cGVdIHx8IHBhbkZ1bmN0aW9ucy5kZWZhdWx0O1xuICBpZiAoY2FsbGJhY2soZm4sIFtzY2FsZSwgZGVsdGEsIGxpbWl0c10pKSB7XG4gICAgcGFuRGVsdGFbc2NhbGUuaWRdID0gMDtcbiAgfSBlbHNlIHtcbiAgICBwYW5EZWx0YVtzY2FsZS5pZF0gPSBkZWx0YTtcbiAgfVxufVxuZnVuY3Rpb24gcGFuKGNoYXJ0LCBkZWx0YSwgZW5hYmxlZFNjYWxlcywgdHJhbnNpdGlvbiA9ICdub25lJykge1xuICBjb25zdCB7eCA9IDAsIHkgPSAwfSA9IHR5cGVvZiBkZWx0YSA9PT0gJ251bWJlcicgPyB7eDogZGVsdGEsIHk6IGRlbHRhfSA6IGRlbHRhO1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgY29uc3Qge29wdGlvbnM6IHtwYW46IHBhbk9wdGlvbnMsIGxpbWl0c319ID0gc3RhdGU7XG4gIGNvbnN0IHtvblBhbn0gPSBwYW5PcHRpb25zIHx8IHt9O1xuICBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcbiAgY29uc3QgeEVuYWJsZWQgPSB4ICE9PSAwO1xuICBjb25zdCB5RW5hYmxlZCA9IHkgIT09IDA7XG4gIGVhY2goZW5hYmxlZFNjYWxlcyB8fCBjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHhFbmFibGVkKSB7XG4gICAgICBwYW5TY2FsZShzY2FsZSwgeCwgbGltaXRzLCBzdGF0ZSk7XG4gICAgfSBlbHNlIGlmICghc2NhbGUuaXNIb3Jpem9udGFsKCkgJiYgeUVuYWJsZWQpIHtcbiAgICAgIHBhblNjYWxlKHNjYWxlLCB5LCBsaW1pdHMsIHN0YXRlKTtcbiAgICB9XG4gIH0pO1xuICBjaGFydC51cGRhdGUodHJhbnNpdGlvbik7XG4gIGNhbGxiYWNrKG9uUGFuLCBbe2NoYXJ0fV0pO1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbFNjYWxlQm91bmRzKGNoYXJ0KSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcbiAgY29uc3Qgc2NhbGVCb3VuZHMgPSB7fTtcbiAgZm9yIChjb25zdCBzY2FsZUlkIG9mIE9iamVjdC5rZXlzKGNoYXJ0LnNjYWxlcykpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gc3RhdGUub3JpZ2luYWxTY2FsZUxpbWl0c1tzY2FsZUlkXSB8fCB7bWluOiB7fSwgbWF4OiB7fX07XG4gICAgc2NhbGVCb3VuZHNbc2NhbGVJZF0gPSB7bWluOiBtaW4uc2NhbGUsIG1heDogbWF4LnNjYWxlfTtcbiAgfVxuICByZXR1cm4gc2NhbGVCb3VuZHM7XG59XG5mdW5jdGlvbiBnZXRab29tZWRTY2FsZUJvdW5kcyhjaGFydCkge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgY29uc3Qgc2NhbGVCb3VuZHMgPSB7fTtcbiAgZm9yIChjb25zdCBzY2FsZUlkIG9mIE9iamVjdC5rZXlzKGNoYXJ0LnNjYWxlcykpIHtcbiAgICBzY2FsZUJvdW5kc1tzY2FsZUlkXSA9IHN0YXRlLnVwZGF0ZWRTY2FsZUxpbWl0c1tzY2FsZUlkXTtcbiAgfVxuICByZXR1cm4gc2NhbGVCb3VuZHM7XG59XG5mdW5jdGlvbiBpc1pvb21lZE9yUGFubmVkKGNoYXJ0KSB7XG4gIGNvbnN0IHNjYWxlQm91bmRzID0gZ2V0SW5pdGlhbFNjYWxlQm91bmRzKGNoYXJ0KTtcbiAgZm9yIChjb25zdCBzY2FsZUlkIG9mIE9iamVjdC5rZXlzKGNoYXJ0LnNjYWxlcykpIHtcbiAgICBjb25zdCB7bWluOiBvcmlnaW5hbE1pbiwgbWF4OiBvcmlnaW5hbE1heH0gPSBzY2FsZUJvdW5kc1tzY2FsZUlkXTtcbiAgICBpZiAob3JpZ2luYWxNaW4gIT09IHVuZGVmaW5lZCAmJiBjaGFydC5zY2FsZXNbc2NhbGVJZF0ubWluICE9PSBvcmlnaW5hbE1pbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvcmlnaW5hbE1heCAhPT0gdW5kZWZpbmVkICYmIGNoYXJ0LnNjYWxlc1tzY2FsZUlkXS5tYXggIT09IG9yaWdpbmFsTWF4KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNab29taW5nT3JQYW5uaW5nKGNoYXJ0KSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICByZXR1cm4gc3RhdGUucGFubmluZyB8fCBzdGF0ZS5kcmFnZ2luZztcbn1cblxuY29uc3QgY2xhbXAgPSAoeCwgZnJvbSwgdG8pID0+IE1hdGgubWluKHRvLCBNYXRoLm1heChmcm9tLCB4KSk7XG5mdW5jdGlvbiByZW1vdmVIYW5kbGVyKGNoYXJ0LCB0eXBlKSB7XG4gIGNvbnN0IHtoYW5kbGVyc30gPSBnZXRTdGF0ZShjaGFydCk7XG4gIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXTtcbiAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci50YXJnZXQpIHtcbiAgICBoYW5kbGVyLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgIGRlbGV0ZSBoYW5kbGVyc1t0eXBlXTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkSGFuZGxlcihjaGFydCwgdGFyZ2V0LCB0eXBlLCBoYW5kbGVyKSB7XG4gIGNvbnN0IHtoYW5kbGVycywgb3B0aW9uc30gPSBnZXRTdGF0ZShjaGFydCk7XG4gIGNvbnN0IG9sZEhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXTtcbiAgaWYgKG9sZEhhbmRsZXIgJiYgb2xkSGFuZGxlci50YXJnZXQgPT09IHRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCB0eXBlKTtcbiAgaGFuZGxlcnNbdHlwZV0gPSAoZXZlbnQpID0+IGhhbmRsZXIoY2hhcnQsIGV2ZW50LCBvcHRpb25zKTtcbiAgaGFuZGxlcnNbdHlwZV0udGFyZ2V0ID0gdGFyZ2V0O1xuICBjb25zdCBwYXNzaXZlID0gdHlwZSA9PT0gJ3doZWVsJyA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyc1t0eXBlXSwge3Bhc3NpdmV9KTtcbn1cbmZ1bmN0aW9uIG1vdXNlTW92ZShjaGFydCwgZXZlbnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGlmIChzdGF0ZS5kcmFnU3RhcnQpIHtcbiAgICBzdGF0ZS5kcmFnZ2luZyA9IHRydWU7XG4gICAgc3RhdGUuZHJhZ0VuZCA9IGV2ZW50O1xuICAgIGNoYXJ0LnVwZGF0ZSgnbm9uZScpO1xuICB9XG59XG5mdW5jdGlvbiBrZXlEb3duKGNoYXJ0LCBldmVudCkge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgaWYgKCFzdGF0ZS5kcmFnU3RhcnQgfHwgZXZlbnQua2V5ICE9PSAnRXNjYXBlJykge1xuICAgIHJldHVybjtcbiAgfVxuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAna2V5ZG93bicpO1xuICBzdGF0ZS5kcmFnZ2luZyA9IGZhbHNlO1xuICBzdGF0ZS5kcmFnU3RhcnQgPSBzdGF0ZS5kcmFnRW5kID0gbnVsbDtcbiAgY2hhcnQudXBkYXRlKCdub25lJyk7XG59XG5mdW5jdGlvbiBnZXRQb2ludFBvc2l0aW9uKGV2ZW50LCBjaGFydCkge1xuICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBjaGFydC5jYW52YXMpIHtcbiAgICBjb25zdCBjYW52YXNBcmVhID0gY2hhcnQuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBldmVudC5jbGllbnRYIC0gY2FudmFzQXJlYS5sZWZ0LFxuICAgICAgeTogZXZlbnQuY2xpZW50WSAtIGNhbnZhc0FyZWEudG9wLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIHpvb21TdGFydChjaGFydCwgZXZlbnQsIHpvb21PcHRpb25zKSB7XG4gIGNvbnN0IHtvblpvb21TdGFydCwgb25ab29tUmVqZWN0ZWR9ID0gem9vbU9wdGlvbnM7XG4gIGlmIChvblpvb21TdGFydCkge1xuICAgIGNvbnN0IHBvaW50ID0gZ2V0UG9pbnRQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICAgIGlmIChjYWxsYmFjayhvblpvb21TdGFydCwgW3tjaGFydCwgZXZlbnQsIHBvaW50fV0pID09PSBmYWxzZSkge1xuICAgICAgY2FsbGJhY2sob25ab29tUmVqZWN0ZWQsIFt7Y2hhcnQsIGV2ZW50fV0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbW91c2VEb3duKGNoYXJ0LCBldmVudCkge1xuICBpZiAoY2hhcnQubGVnZW5kKSB7XG4gICAgY29uc3QgcG9pbnQgPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gICAgaWYgKF9pc1BvaW50SW5BcmVhKHBvaW50LCBjaGFydC5sZWdlbmQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCB7cGFuOiBwYW5PcHRpb25zLCB6b29tOiB6b29tT3B0aW9ucyA9IHt9fSA9IHN0YXRlLm9wdGlvbnM7XG4gIGlmIChcbiAgICBldmVudC5idXR0b24gIT09IDAgfHxcbiAgICBrZXlQcmVzc2VkKGdldE1vZGlmaWVyS2V5KHBhbk9wdGlvbnMpLCBldmVudCkgfHxcbiAgICBrZXlOb3RQcmVzc2VkKGdldE1vZGlmaWVyS2V5KHpvb21PcHRpb25zLmRyYWcpLCBldmVudClcbiAgKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHpvb21PcHRpb25zLm9uWm9vbVJlamVjdGVkLCBbe2NoYXJ0LCBldmVudH1dKTtcbiAgfVxuICBpZiAoem9vbVN0YXJ0KGNoYXJ0LCBldmVudCwgem9vbU9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzdGF0ZS5kcmFnU3RhcnQgPSBldmVudDtcbiAgYWRkSGFuZGxlcihjaGFydCwgY2hhcnQuY2FudmFzLm93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZU1vdmUpO1xuICBhZGRIYW5kbGVyKGNoYXJ0LCB3aW5kb3cuZG9jdW1lbnQsICdrZXlkb3duJywga2V5RG93bik7XG59XG5mdW5jdGlvbiBhcHBseUFzcGVjdFJhdGlvKHtiZWdpbiwgZW5kfSwgYXNwZWN0UmF0aW8pIHtcbiAgbGV0IHdpZHRoID0gZW5kLnggLSBiZWdpbi54O1xuICBsZXQgaGVpZ2h0ID0gZW5kLnkgLSBiZWdpbi55O1xuICBjb25zdCByYXRpbyA9IE1hdGguYWJzKHdpZHRoIC8gaGVpZ2h0KTtcbiAgaWYgKHJhdGlvID4gYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGguc2lnbih3aWR0aCkgKiBNYXRoLmFicyhoZWlnaHQgKiBhc3BlY3RSYXRpbyk7XG4gIH0gZWxzZSBpZiAocmF0aW8gPCBhc3BlY3RSYXRpbykge1xuICAgIGhlaWdodCA9IE1hdGguc2lnbihoZWlnaHQpICogTWF0aC5hYnMod2lkdGggLyBhc3BlY3RSYXRpbyk7XG4gIH1cbiAgZW5kLnggPSBiZWdpbi54ICsgd2lkdGg7XG4gIGVuZC55ID0gYmVnaW4ueSArIGhlaWdodDtcbn1cbmZ1bmN0aW9uIGFwcGx5TWluTWF4UHJvcHMocmVjdCwgY2hhcnRBcmVhLCBwb2ludHMsIHttaW4sIG1heCwgcHJvcH0pIHtcbiAgcmVjdFttaW5dID0gY2xhbXAoTWF0aC5taW4ocG9pbnRzLmJlZ2luW3Byb3BdLCBwb2ludHMuZW5kW3Byb3BdKSwgY2hhcnRBcmVhW21pbl0sIGNoYXJ0QXJlYVttYXhdKTtcbiAgcmVjdFttYXhdID0gY2xhbXAoTWF0aC5tYXgocG9pbnRzLmJlZ2luW3Byb3BdLCBwb2ludHMuZW5kW3Byb3BdKSwgY2hhcnRBcmVhW21pbl0sIGNoYXJ0QXJlYVttYXhdKTtcbn1cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9pbnRzKGNoYXJ0LCBwb2ludEV2ZW50cywgbWFpbnRhaW5Bc3BlY3RSYXRpbykge1xuICBjb25zdCBwb2ludHMgPSB7XG4gICAgYmVnaW46IGdldFBvaW50UG9zaXRpb24ocG9pbnRFdmVudHMuZHJhZ1N0YXJ0LCBjaGFydCksXG4gICAgZW5kOiBnZXRQb2ludFBvc2l0aW9uKHBvaW50RXZlbnRzLmRyYWdFbmQsIGNoYXJ0KSxcbiAgfTtcbiAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8pIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGNoYXJ0LmNoYXJ0QXJlYS53aWR0aCAvIGNoYXJ0LmNoYXJ0QXJlYS5oZWlnaHQ7XG4gICAgYXBwbHlBc3BlY3RSYXRpbyhwb2ludHMsIGFzcGVjdFJhdGlvKTtcbiAgfVxuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gY29tcHV0ZURyYWdSZWN0KGNoYXJ0LCBtb2RlLCBwb2ludEV2ZW50cywgbWFpbnRhaW5Bc3BlY3RSYXRpbykge1xuICBjb25zdCB4RW5hYmxlZCA9IGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3gnLCBjaGFydCk7XG4gIGNvbnN0IHlFbmFibGVkID0gZGlyZWN0aW9uRW5hYmxlZChtb2RlLCAneScsIGNoYXJ0KTtcbiAgY29uc3Qge3RvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgd2lkdGg6IGNoYXJ0V2lkdGgsIGhlaWdodDogY2hhcnRIZWlnaHR9ID0gY2hhcnQuY2hhcnRBcmVhO1xuICBjb25zdCByZWN0ID0ge3RvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbX07XG4gIGNvbnN0IHBvaW50cyA9IGdldFJlbGF0aXZlUG9pbnRzKGNoYXJ0LCBwb2ludEV2ZW50cywgbWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB4RW5hYmxlZCAmJiB5RW5hYmxlZCk7XG4gIGlmICh4RW5hYmxlZCkge1xuICAgIGFwcGx5TWluTWF4UHJvcHMocmVjdCwgY2hhcnQuY2hhcnRBcmVhLCBwb2ludHMsIHttaW46ICdsZWZ0JywgbWF4OiAncmlnaHQnLCBwcm9wOiAneCd9KTtcbiAgfVxuICBpZiAoeUVuYWJsZWQpIHtcbiAgICBhcHBseU1pbk1heFByb3BzKHJlY3QsIGNoYXJ0LmNoYXJ0QXJlYSwgcG9pbnRzLCB7bWluOiAndG9wJywgbWF4OiAnYm90dG9tJywgcHJvcDogJ3knfSk7XG4gIH1cbiAgY29uc3Qgd2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICByZXR1cm4ge1xuICAgIC4uLnJlY3QsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHpvb21YOiB4RW5hYmxlZCAmJiB3aWR0aCA/IDEgKyAoKGNoYXJ0V2lkdGggLSB3aWR0aCkgLyBjaGFydFdpZHRoKSA6IDEsXG4gICAgem9vbVk6IHlFbmFibGVkICYmIGhlaWdodCA/IDEgKyAoKGNoYXJ0SGVpZ2h0IC0gaGVpZ2h0KSAvIGNoYXJ0SGVpZ2h0KSA6IDFcbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdXNlVXAoY2hhcnQsIGV2ZW50KSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBpZiAoIXN0YXRlLmRyYWdTdGFydCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnbW91c2Vtb3ZlJyk7XG4gIGNvbnN0IHttb2RlLCBvblpvb21Db21wbGV0ZSwgZHJhZzoge3RocmVzaG9sZCA9IDAsIG1haW50YWluQXNwZWN0UmF0aW99fSA9IHN0YXRlLm9wdGlvbnMuem9vbTtcbiAgY29uc3QgcmVjdCA9IGNvbXB1dGVEcmFnUmVjdChjaGFydCwgbW9kZSwge2RyYWdTdGFydDogc3RhdGUuZHJhZ1N0YXJ0LCBkcmFnRW5kOiBldmVudH0sIG1haW50YWluQXNwZWN0UmF0aW8pO1xuICBjb25zdCBkaXN0YW5jZVggPSBkaXJlY3Rpb25FbmFibGVkKG1vZGUsICd4JywgY2hhcnQpID8gcmVjdC53aWR0aCA6IDA7XG4gIGNvbnN0IGRpc3RhbmNlWSA9IGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3knLCBjaGFydCkgPyByZWN0LmhlaWdodCA6IDA7XG4gIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWSk7XG4gIHN0YXRlLmRyYWdTdGFydCA9IHN0YXRlLmRyYWdFbmQgPSBudWxsO1xuICBpZiAoZGlzdGFuY2UgPD0gdGhyZXNob2xkKSB7XG4gICAgc3RhdGUuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBjaGFydC51cGRhdGUoJ25vbmUnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgem9vbVJlY3QoY2hhcnQsIHt4OiByZWN0LmxlZnQsIHk6IHJlY3QudG9wfSwge3g6IHJlY3QucmlnaHQsIHk6IHJlY3QuYm90dG9tfSwgJ3pvb20nLCAnZHJhZycpO1xuICBzdGF0ZS5kcmFnZ2luZyA9IGZhbHNlO1xuICBzdGF0ZS5maWx0ZXJOZXh0Q2xpY2sgPSB0cnVlO1xuICBjYWxsYmFjayhvblpvb21Db21wbGV0ZSwgW3tjaGFydH1dKTtcbn1cbmZ1bmN0aW9uIHdoZWVsUHJlY29uZGl0aW9ucyhjaGFydCwgZXZlbnQsIHpvb21PcHRpb25zKSB7XG4gIGlmIChrZXlOb3RQcmVzc2VkKGdldE1vZGlmaWVyS2V5KHpvb21PcHRpb25zLndoZWVsKSwgZXZlbnQpKSB7XG4gICAgY2FsbGJhY2soem9vbU9wdGlvbnMub25ab29tUmVqZWN0ZWQsIFt7Y2hhcnQsIGV2ZW50fV0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoem9vbVN0YXJ0KGNoYXJ0LCBldmVudCwgem9vbU9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKGV2ZW50LmRlbHRhWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gd2hlZWwoY2hhcnQsIGV2ZW50KSB7XG4gIGNvbnN0IHtoYW5kbGVyczoge29uWm9vbUNvbXBsZXRlfSwgb3B0aW9uczoge3pvb206IHpvb21PcHRpb25zfX0gPSBnZXRTdGF0ZShjaGFydCk7XG4gIGlmICghd2hlZWxQcmVjb25kaXRpb25zKGNoYXJ0LCBldmVudCwgem9vbU9wdGlvbnMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBldmVudC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHNwZWVkID0gem9vbU9wdGlvbnMud2hlZWwuc3BlZWQ7XG4gIGNvbnN0IHBlcmNlbnRhZ2UgPSBldmVudC5kZWx0YVkgPj0gMCA/IDIgLSAxIC8gKDEgLSBzcGVlZCkgOiAxICsgc3BlZWQ7XG4gIGNvbnN0IGFtb3VudCA9IHtcbiAgICB4OiBwZXJjZW50YWdlLFxuICAgIHk6IHBlcmNlbnRhZ2UsXG4gICAgZm9jYWxQb2ludDoge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH1cbiAgfTtcbiAgem9vbShjaGFydCwgYW1vdW50LCAnem9vbScsICd3aGVlbCcpO1xuICBjYWxsYmFjayhvblpvb21Db21wbGV0ZSwgW3tjaGFydH1dKTtcbn1cbmZ1bmN0aW9uIGFkZERlYm91bmNlZEhhbmRsZXIoY2hhcnQsIG5hbWUsIGhhbmRsZXIsIGRlbGF5KSB7XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgZ2V0U3RhdGUoY2hhcnQpLmhhbmRsZXJzW25hbWVdID0gZGVib3VuY2UoKCkgPT4gY2FsbGJhY2soaGFuZGxlciwgW3tjaGFydH1dKSwgZGVsYXkpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoY2hhcnQsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCB7d2hlZWw6IHdoZWVsT3B0aW9ucywgZHJhZzogZHJhZ09wdGlvbnMsIG9uWm9vbUNvbXBsZXRlfSA9IG9wdGlvbnMuem9vbTtcbiAgaWYgKHdoZWVsT3B0aW9ucy5lbmFibGVkKSB7XG4gICAgYWRkSGFuZGxlcihjaGFydCwgY2FudmFzLCAnd2hlZWwnLCB3aGVlbCk7XG4gICAgYWRkRGVib3VuY2VkSGFuZGxlcihjaGFydCwgJ29uWm9vbUNvbXBsZXRlJywgb25ab29tQ29tcGxldGUsIDI1MCk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ3doZWVsJyk7XG4gIH1cbiAgaWYgKGRyYWdPcHRpb25zLmVuYWJsZWQpIHtcbiAgICBhZGRIYW5kbGVyKGNoYXJ0LCBjYW52YXMsICdtb3VzZWRvd24nLCBtb3VzZURvd24pO1xuICAgIGFkZEhhbmRsZXIoY2hhcnQsIGNhbnZhcy5vd25lckRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNlVXApO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdtb3VzZWRvd24nKTtcbiAgICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnbW91c2Vtb3ZlJyk7XG4gICAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ21vdXNldXAnKTtcbiAgICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAna2V5ZG93bicpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoY2hhcnQpIHtcbiAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ21vdXNlZG93bicpO1xuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnbW91c2Vtb3ZlJyk7XG4gIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdtb3VzZXVwJyk7XG4gIHJlbW92ZUhhbmRsZXIoY2hhcnQsICd3aGVlbCcpO1xuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnY2xpY2snKTtcbiAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ2tleWRvd24nKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW5hYmxlcihjaGFydCwgc3RhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHJlY29nbml6ZXIsIGV2ZW50KSB7XG4gICAgY29uc3Qge3BhbjogcGFuT3B0aW9ucywgem9vbTogem9vbU9wdGlvbnMgPSB7fX0gPSBzdGF0ZS5vcHRpb25zO1xuICAgIGlmICghcGFuT3B0aW9ucyB8fCAhcGFuT3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNyY0V2ZW50ID0gZXZlbnQgJiYgZXZlbnQuc3JjRXZlbnQ7XG4gICAgaWYgKCFzcmNFdmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghc3RhdGUucGFubmluZyAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyAmJiAoXG4gICAgICBrZXlOb3RQcmVzc2VkKGdldE1vZGlmaWVyS2V5KHBhbk9wdGlvbnMpLCBzcmNFdmVudCkgfHwga2V5UHJlc3NlZChnZXRNb2RpZmllcktleSh6b29tT3B0aW9ucy5kcmFnKSwgc3JjRXZlbnQpKVxuICAgICkge1xuICAgICAgY2FsbGJhY2socGFuT3B0aW9ucy5vblBhblJlamVjdGVkLCBbe2NoYXJ0LCBldmVudH1dKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiBwaW5jaEF4ZXMocDAsIHAxKSB7XG4gIGNvbnN0IHBpbmNoWCA9IE1hdGguYWJzKHAwLmNsaWVudFggLSBwMS5jbGllbnRYKTtcbiAgY29uc3QgcGluY2hZID0gTWF0aC5hYnMocDAuY2xpZW50WSAtIHAxLmNsaWVudFkpO1xuICBjb25zdCBwID0gcGluY2hYIC8gcGluY2hZO1xuICBsZXQgeCwgeTtcbiAgaWYgKHAgPiAwLjMgJiYgcCA8IDEuNykge1xuICAgIHggPSB5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChwaW5jaFggPiBwaW5jaFkpIHtcbiAgICB4ID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHl9O1xufVxuZnVuY3Rpb24gaGFuZGxlUGluY2goY2hhcnQsIHN0YXRlLCBlKSB7XG4gIGlmIChzdGF0ZS5zY2FsZSkge1xuICAgIGNvbnN0IHtjZW50ZXIsIHBvaW50ZXJzfSA9IGU7XG4gICAgY29uc3Qgem9vbVBlcmNlbnQgPSAxIC8gc3RhdGUuc2NhbGUgKiBlLnNjYWxlO1xuICAgIGNvbnN0IHJlY3QgPSBlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBwaW5jaCA9IHBpbmNoQXhlcyhwb2ludGVyc1swXSwgcG9pbnRlcnNbMV0pO1xuICAgIGNvbnN0IG1vZGUgPSBzdGF0ZS5vcHRpb25zLnpvb20ubW9kZTtcbiAgICBjb25zdCBhbW91bnQgPSB7XG4gICAgICB4OiBwaW5jaC54ICYmIGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3gnLCBjaGFydCkgPyB6b29tUGVyY2VudCA6IDEsXG4gICAgICB5OiBwaW5jaC55ICYmIGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3knLCBjaGFydCkgPyB6b29tUGVyY2VudCA6IDEsXG4gICAgICBmb2NhbFBvaW50OiB7XG4gICAgICAgIHg6IGNlbnRlci54IC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBjZW50ZXIueSAtIHJlY3QudG9wXG4gICAgICB9XG4gICAgfTtcbiAgICB6b29tKGNoYXJ0LCBhbW91bnQsICd6b29tJywgJ3BpbmNoJyk7XG4gICAgc3RhdGUuc2NhbGUgPSBlLnNjYWxlO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFBpbmNoKGNoYXJ0LCBzdGF0ZSwgZXZlbnQpIHtcbiAgaWYgKHN0YXRlLm9wdGlvbnMuem9vbS5waW5jaC5lbmFibGVkKSB7XG4gICAgY29uc3QgcG9pbnQgPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gICAgaWYgKGNhbGxiYWNrKHN0YXRlLm9wdGlvbnMuem9vbS5vblpvb21TdGFydCwgW3tjaGFydCwgZXZlbnQsIHBvaW50fV0pID09PSBmYWxzZSkge1xuICAgICAgc3RhdGUuc2NhbGUgPSBudWxsO1xuICAgICAgY2FsbGJhY2soc3RhdGUub3B0aW9ucy56b29tLm9uWm9vbVJlamVjdGVkLCBbe2NoYXJ0LCBldmVudH1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuc2NhbGUgPSAxO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5kUGluY2goY2hhcnQsIHN0YXRlLCBlKSB7XG4gIGlmIChzdGF0ZS5zY2FsZSkge1xuICAgIGhhbmRsZVBpbmNoKGNoYXJ0LCBzdGF0ZSwgZSk7XG4gICAgc3RhdGUuc2NhbGUgPSBudWxsO1xuICAgIGNhbGxiYWNrKHN0YXRlLm9wdGlvbnMuem9vbS5vblpvb21Db21wbGV0ZSwgW3tjaGFydH1dKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlUGFuKGNoYXJ0LCBzdGF0ZSwgZSkge1xuICBjb25zdCBkZWx0YSA9IHN0YXRlLmRlbHRhO1xuICBpZiAoZGVsdGEpIHtcbiAgICBzdGF0ZS5wYW5uaW5nID0gdHJ1ZTtcbiAgICBwYW4oY2hhcnQsIHt4OiBlLmRlbHRhWCAtIGRlbHRhLngsIHk6IGUuZGVsdGFZIC0gZGVsdGEueX0sIHN0YXRlLnBhblNjYWxlcyk7XG4gICAgc3RhdGUuZGVsdGEgPSB7eDogZS5kZWx0YVgsIHk6IGUuZGVsdGFZfTtcbiAgfVxufVxuZnVuY3Rpb24gc3RhcnRQYW4oY2hhcnQsIHN0YXRlLCBldmVudCkge1xuICBjb25zdCB7ZW5hYmxlZCwgb25QYW5TdGFydCwgb25QYW5SZWplY3RlZH0gPSBzdGF0ZS5vcHRpb25zLnBhbjtcbiAgaWYgKCFlbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBldmVudC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHBvaW50ID0ge1xuICAgIHg6IGV2ZW50LmNlbnRlci54IC0gcmVjdC5sZWZ0LFxuICAgIHk6IGV2ZW50LmNlbnRlci55IC0gcmVjdC50b3BcbiAgfTtcbiAgaWYgKGNhbGxiYWNrKG9uUGFuU3RhcnQsIFt7Y2hhcnQsIGV2ZW50LCBwb2ludH1dKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sob25QYW5SZWplY3RlZCwgW3tjaGFydCwgZXZlbnR9XSk7XG4gIH1cbiAgc3RhdGUucGFuU2NhbGVzID0gZ2V0RW5hYmxlZFNjYWxlc0J5UG9pbnQoc3RhdGUub3B0aW9ucy5wYW4sIHBvaW50LCBjaGFydCk7XG4gIHN0YXRlLmRlbHRhID0ge3g6IDAsIHk6IDB9O1xuICBoYW5kbGVQYW4oY2hhcnQsIHN0YXRlLCBldmVudCk7XG59XG5mdW5jdGlvbiBlbmRQYW4oY2hhcnQsIHN0YXRlKSB7XG4gIHN0YXRlLmRlbHRhID0gbnVsbDtcbiAgaWYgKHN0YXRlLnBhbm5pbmcpIHtcbiAgICBzdGF0ZS5wYW5uaW5nID0gZmFsc2U7XG4gICAgc3RhdGUuZmlsdGVyTmV4dENsaWNrID0gdHJ1ZTtcbiAgICBjYWxsYmFjayhzdGF0ZS5vcHRpb25zLnBhbi5vblBhbkNvbXBsZXRlLCBbe2NoYXJ0fV0pO1xuICB9XG59XG5jb25zdCBoYW1tZXJzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHN0YXJ0SGFtbWVyKGNoYXJ0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IHtwYW46IHBhbk9wdGlvbnMsIHpvb206IHpvb21PcHRpb25zfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1jID0gbmV3IEhhbW1lci5NYW5hZ2VyKGNhbnZhcyk7XG4gIGlmICh6b29tT3B0aW9ucyAmJiB6b29tT3B0aW9ucy5waW5jaC5lbmFibGVkKSB7XG4gICAgbWMuYWRkKG5ldyBIYW1tZXIuUGluY2goKSk7XG4gICAgbWMub24oJ3BpbmNoc3RhcnQnLCAoZSkgPT4gc3RhcnRQaW5jaChjaGFydCwgc3RhdGUsIGUpKTtcbiAgICBtYy5vbigncGluY2gnLCAoZSkgPT4gaGFuZGxlUGluY2goY2hhcnQsIHN0YXRlLCBlKSk7XG4gICAgbWMub24oJ3BpbmNoZW5kJywgKGUpID0+IGVuZFBpbmNoKGNoYXJ0LCBzdGF0ZSwgZSkpO1xuICB9XG4gIGlmIChwYW5PcHRpb25zICYmIHBhbk9wdGlvbnMuZW5hYmxlZCkge1xuICAgIG1jLmFkZChuZXcgSGFtbWVyLlBhbih7XG4gICAgICB0aHJlc2hvbGQ6IHBhbk9wdGlvbnMudGhyZXNob2xkLFxuICAgICAgZW5hYmxlOiBjcmVhdGVFbmFibGVyKGNoYXJ0LCBzdGF0ZSlcbiAgICB9KSk7XG4gICAgbWMub24oJ3BhbnN0YXJ0JywgKGUpID0+IHN0YXJ0UGFuKGNoYXJ0LCBzdGF0ZSwgZSkpO1xuICAgIG1jLm9uKCdwYW5tb3ZlJywgKGUpID0+IGhhbmRsZVBhbihjaGFydCwgc3RhdGUsIGUpKTtcbiAgICBtYy5vbigncGFuZW5kJywgKCkgPT4gZW5kUGFuKGNoYXJ0LCBzdGF0ZSkpO1xuICB9XG4gIGhhbW1lcnMuc2V0KGNoYXJ0LCBtYyk7XG59XG5mdW5jdGlvbiBzdG9wSGFtbWVyKGNoYXJ0KSB7XG4gIGNvbnN0IG1jID0gaGFtbWVycy5nZXQoY2hhcnQpO1xuICBpZiAobWMpIHtcbiAgICBtYy5yZW1vdmUoJ3BpbmNoc3RhcnQnKTtcbiAgICBtYy5yZW1vdmUoJ3BpbmNoJyk7XG4gICAgbWMucmVtb3ZlKCdwaW5jaGVuZCcpO1xuICAgIG1jLnJlbW92ZSgncGFuc3RhcnQnKTtcbiAgICBtYy5yZW1vdmUoJ3BhbicpO1xuICAgIG1jLnJlbW92ZSgncGFuZW5kJyk7XG4gICAgbWMuZGVzdHJveSgpO1xuICAgIGhhbW1lcnMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxuZnVuY3Rpb24gaGFtbWVyT3B0aW9uc0NoYW5nZWQob2xkT3B0aW9ucywgbmV3T3B0aW9ucykge1xuICBjb25zdCB7cGFuOiBvbGRQYW4sIHpvb206IG9sZFpvb219ID0gb2xkT3B0aW9ucztcbiAgY29uc3Qge3BhbjogbmV3UGFuLCB6b29tOiBuZXdab29tfSA9IG5ld09wdGlvbnM7XG4gIGlmIChvbGRab29tPy56b29tPy5waW5jaD8uZW5hYmxlZCAhPT0gbmV3Wm9vbT8uem9vbT8ucGluY2g/LmVuYWJsZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob2xkUGFuPy5lbmFibGVkICE9PSBuZXdQYW4/LmVuYWJsZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob2xkUGFuPy50aHJlc2hvbGQgIT09IG5ld1Bhbj8udGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMi4yLjBcIjtcblxuZnVuY3Rpb24gZHJhdyhjaGFydCwgY2FsbGVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRyYWdPcHRpb25zID0gb3B0aW9ucy56b29tLmRyYWc7XG4gIGNvbnN0IHtkcmFnU3RhcnQsIGRyYWdFbmR9ID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBpZiAoZHJhZ09wdGlvbnMuZHJhd1RpbWUgIT09IGNhbGxlciB8fCAhZHJhZ0VuZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7bGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IGNvbXB1dGVEcmFnUmVjdChjaGFydCwgb3B0aW9ucy56b29tLm1vZGUsIHtkcmFnU3RhcnQsIGRyYWdFbmR9LCBkcmFnT3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvKTtcbiAgY29uc3QgY3R4ID0gY2hhcnQuY3R4O1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5maWxsU3R5bGUgPSBkcmFnT3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3JnYmEoMjI1LDIyNSwyMjUsMC4zKSc7XG4gIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICBpZiAoZHJhZ09wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGRyYWdPcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGRyYWdPcHRpb25zLmJvcmRlckNvbG9yIHx8ICdyZ2JhKDIyNSwyMjUsMjI1KSc7XG4gICAgY3R4LnN0cm9rZVJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxudmFyIHBsdWdpbiA9IHtcbiAgaWQ6ICd6b29tJyxcbiAgdmVyc2lvbixcbiAgZGVmYXVsdHM6IHtcbiAgICBwYW46IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgbW9kZTogJ3h5JyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICBtb2RpZmllcktleTogbnVsbCxcbiAgICB9LFxuICAgIHpvb206IHtcbiAgICAgIHdoZWVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzcGVlZDogMC4xLFxuICAgICAgICBtb2RpZmllcktleTogbnVsbFxuICAgICAgfSxcbiAgICAgIGRyYWc6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldHNEcmF3JyxcbiAgICAgICAgbW9kaWZpZXJLZXk6IG51bGxcbiAgICAgIH0sXG4gICAgICBwaW5jaDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG1vZGU6ICd4eScsXG4gICAgfVxuICB9LFxuICBzdGFydDogZnVuY3Rpb24oY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gICAgc3RhdGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnpvb20sICdlbmFibGVkJykpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGhlIG9wdGlvbiBgem9vbS5lbmFibGVkYCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGB6b29tLndoZWVsLmVuYWJsZWRgLCBgem9vbS5kcmFnLmVuYWJsZWRgLCBvciBgem9vbS5waW5jaC5lbmFibGVkYC4nKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnpvb20sICdvdmVyU2NhbGVNb2RlJylcbiAgICAgIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhbiwgJ292ZXJTY2FsZU1vZGUnKSkge1xuICAgICAgY29uc29sZS53YXJuKCdUaGUgb3B0aW9uIGBvdmVyU2NhbGVNb2RlYCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBzY2FsZU1vZGVgIGluc3RlYWQgKGFuZCB1cGRhdGUgYG1vZGVgIGFzIGRlc2lyZWQpLicpO1xuICAgIH1cbiAgICBpZiAoSGFtbWVyKSB7XG4gICAgICBzdGFydEhhbW1lcihjaGFydCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNoYXJ0LnBhbiA9IChkZWx0YSwgcGFuU2NhbGVzLCB0cmFuc2l0aW9uKSA9PiBwYW4oY2hhcnQsIGRlbHRhLCBwYW5TY2FsZXMsIHRyYW5zaXRpb24pO1xuICAgIGNoYXJ0Lnpvb20gPSAoYXJncywgdHJhbnNpdGlvbikgPT4gem9vbShjaGFydCwgYXJncywgdHJhbnNpdGlvbik7XG4gICAgY2hhcnQuem9vbVJlY3QgPSAocDAsIHAxLCB0cmFuc2l0aW9uKSA9PiB6b29tUmVjdChjaGFydCwgcDAsIHAxLCB0cmFuc2l0aW9uKTtcbiAgICBjaGFydC56b29tU2NhbGUgPSAoaWQsIHJhbmdlLCB0cmFuc2l0aW9uKSA9PiB6b29tU2NhbGUoY2hhcnQsIGlkLCByYW5nZSwgdHJhbnNpdGlvbik7XG4gICAgY2hhcnQucmVzZXRab29tID0gKHRyYW5zaXRpb24pID0+IHJlc2V0Wm9vbShjaGFydCwgdHJhbnNpdGlvbik7XG4gICAgY2hhcnQuZ2V0Wm9vbUxldmVsID0gKCkgPT4gZ2V0Wm9vbUxldmVsKGNoYXJ0KTtcbiAgICBjaGFydC5nZXRJbml0aWFsU2NhbGVCb3VuZHMgPSAoKSA9PiBnZXRJbml0aWFsU2NhbGVCb3VuZHMoY2hhcnQpO1xuICAgIGNoYXJ0LmdldFpvb21lZFNjYWxlQm91bmRzID0gKCkgPT4gZ2V0Wm9vbWVkU2NhbGVCb3VuZHMoY2hhcnQpO1xuICAgIGNoYXJ0LmlzWm9vbWVkT3JQYW5uZWQgPSAoKSA9PiBpc1pvb21lZE9yUGFubmVkKGNoYXJ0KTtcbiAgICBjaGFydC5pc1pvb21pbmdPclBhbm5pbmcgPSAoKSA9PiBpc1pvb21pbmdPclBhbm5pbmcoY2hhcnQpO1xuICB9LFxuICBiZWZvcmVFdmVudChjaGFydCwge2V2ZW50fSkge1xuICAgIGlmIChpc1pvb21pbmdPclBhbm5pbmcoY2hhcnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snIHx8IGV2ZW50LnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gICAgICBpZiAoc3RhdGUuZmlsdGVyTmV4dENsaWNrKSB7XG4gICAgICAgIHN0YXRlLmZpbHRlck5leHRDbGljayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gICAgY29uc3QgcHJldmlvdXNPcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgICBzdGF0ZS5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAoaGFtbWVyT3B0aW9uc0NoYW5nZWQocHJldmlvdXNPcHRpb25zLCBvcHRpb25zKSkge1xuICAgICAgc3RvcEhhbW1lcihjaGFydCk7XG4gICAgICBzdGFydEhhbW1lcihjaGFydCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVycyhjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYmVmb3JlRGF0YXNldHNEcmF3Jywgb3B0aW9ucyk7XG4gIH0sXG4gIGFmdGVyRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGRyYXcoY2hhcnQsICdhZnRlckRhdGFzZXRzRHJhdycsIG9wdGlvbnMpO1xuICB9LFxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGRyYXcoY2hhcnQsICdiZWZvcmVEcmF3Jywgb3B0aW9ucyk7XG4gIH0sXG4gIGFmdGVyRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYWZ0ZXJEcmF3Jywgb3B0aW9ucyk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKGNoYXJ0KTtcbiAgICBpZiAoSGFtbWVyKSB7XG4gICAgICBzdG9wSGFtbWVyKGNoYXJ0KTtcbiAgICB9XG4gICAgcmVtb3ZlU3RhdGUoY2hhcnQpO1xuICB9LFxuICBwYW5GdW5jdGlvbnMsXG4gIHpvb21GdW5jdGlvbnMsXG4gIHpvb21SZWN0RnVuY3Rpb25zLFxufTtcblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQsIHBhbiwgcmVzZXRab29tLCB6b29tLCB6b29tUmVjdCwgem9vbVNjYWxlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js\n");

/***/ })

};
;